import re\nimport logging\nfrom typing import List, Dict, Any, Optional, Tuple\n\nlogger = logging.getLogger(__name__)\n\ndef parse_monetary_value(value_str: str) -> Optional[float]:\n    \"\"\"Converts a monetary string (e.g., \"$10.5M\", \"250K\", \"€1,200.50\") to a float.\n       Returns None if parsing fails.\n    \"\"\"\n    if not isinstance(value_str, str):\n        return None\n\n    # Remove currency symbols and commas\n    cleaned_str = re.sub(r\"[$,€£¥]\", \"\", value_str)\n    cleaned_str = cleaned_str.replace(\",\", \"\")\n\n    multiplier = 1.0\n    if cleaned_str.upper().endswith(\'K\'):\n        multiplier = 1_000.0\n        cleaned_str = cleaned_str[:-1]\n    elif cleaned_str.upper().endswith(\'M\'):\n        multiplier = 1_000_000.0\n        cleaned_str = cleaned_str[:-1]\n    elif cleaned_str.upper().endswith(\'B\'):\n        multiplier = 1_000_000_000.0\n        cleaned_str = cleaned_str[:-1]\n    \n    try:\n        return float(cleaned_str) * multiplier\n    except ValueError:\n        logger.debug(f\"Could not parse monetary value: {value_str}\")\n        return None\n\nKPI_PATTERNS = [\n    {\n        \"type\": \"MONEY\",\n        # Covers $100, $1,000, $1.2M, €50k, £2.5B, ¥10000, also without currency symbol if context implies money (e.g. from ARR)\n        # Includes optional K, M, B suffixes (case-insensitive)\n        \"regex\": r\"([$€£¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?)(?!\\s*%(?:\\s|$))\", # Exclude if followed by %\n        \"value_parser\": parse_monetary_value,\n        \"context_words\": None # Can add words like \"revenue\", \"raised\", \"cost\" if needed for disambiguation\n    },\n    {\n        \"type\": \"PERCENTAGE\",\n        \"regex\": r\"(\\d[\\d,]*\\.?\\d*\\s*%)\",\n        \"value_parser\": lambda x: float(x.replace(\"%\", \"\").replace(\",\", \"\").strip()) if x else None,\n        \"context_words\": None\n    },\n    {\n        \"type\": \"ARR\", # Annual Recurring Revenue\n        \"regex\": r\"(?i)((?:\\$[\€\£\¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?|\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?\\s*dollars|euros|pounds|yen)\\s*(?:in|of)?\\s*ARR|ARR\\s*(?:of|is|was|at)?\\s*\\$[\€\£\¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?)\",\n        \"value_extractor_regex\": r\"[\$€£¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?\", # Extracts the numeric part from the full match\n        \"value_parser\": parse_monetary_value,\n        \"context_words\": [\"ARR\", \"Annual Recurring Revenue\"]\n    },\n    {\n        \"type\": \"MRR\", # Monthly Recurring Revenue\n        \"regex\": r\"(?i)((?:\\$[\€\£\¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?|\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?\\s*dollars|euros|pounds|yen)\\s*(?:in|of)?\\s*MRR|MRR\\s*(?:of|is|was|at)?\\s*\\$[\€\£\¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?)\",\n        \"value_extractor_regex\": r\"[\$€£¥]?\\s*\\d[\\d,]*\\.?\\d*\\s*[KMBkmb]?\",\n        \"value_parser\": parse_monetary_value,\n        \"context_words\": [\"MRR\", \"Monthly Recurring Revenue\"]\n    },\n    # Add more patterns for CAC, LTV, funding rounds, valuations etc. as needed\n    # Example for a generic \"Funding Round\" - could be more specific for Series A, B etc.\n    {\n        \"type\": \"FUNDING_ROUND_MONEY\", # Money associated with a funding round\n        \"regex\": r\"(?i)((?:Series\\s+[A-Za-z](?:\\+\\+?)?|Seed(?:\\s+Round)?|Angel(?:\\s+Round)?)(?:\\s+round)?(?:\\s+of|\\s+worth|\\s+at)?\\s+\\$[\\d,]+\\.?\\d*\\s*[KMBkmb]?|\\$[\\d,]+\\.?\\d*\\s*[KMBkmb]?\\s+(?:in\\s+)?(?:Series\\s+[A-Za-z](?:\\+\\+?)?|Seed(?:\\s+Round)?|Angel(?:\\s+Round)?)(?:\\s+round)?)\",\n        \"value_extractor_regex\": r\"\\$[\\d,]+\\.?\\d*\\s*[KMBkmb]?\",\n        \"value_parser\": parse_monetary_value,\n        \"context_words\": [\"series\", \"seed\", \"angel\", \"round\", \"funding\"]\n    },\n    {\n        \"type\": \"VALUATION\",\n        \"regex\": r\"(?i)((?:valued\\s+at|valuation\\s+of|a\\s+\\$[\\d,]+\\.?\\d*\\s*[KMBkmb]?\\s+valuation))\",\n        \"value_extractor_regex\": r\"\\$[\\d,]+\\.?\\d*\\s*[KMBkmb]?\",\n        \"value_parser\": parse_monetary_value,\n        \"context_words\": [\"valuation\", \"valued at\"]\n    }\n]\n\ndef extract_kpis(transcript_text: str) -> List[Dict[str, Any]]:\n    \"\"\"Extracts Key Performance Indicators (KPIs) from transcript text using regex patterns.\"\"\"\n    if not transcript_text or not isinstance(transcript_text, str):\n        logger.warning(\"Transcript text is empty or not a string. Skipping KPI extraction.\")\n        return []\n\n    extracted_kpis: List[Dict[str, Any]] = []\n    # To avoid double-counting a money amount that\'s part of ARR/MRR/Funding, keep track of matched spans\n    matched_spans: List[Tuple[int, int]] = [] \n\n    for kpi_def in KPI_PATTERNS:\n        try:\n            pattern = re.compile(kpi_def[\"regex\"])\n            for match in pattern.finditer(transcript_text):\n                start_char, end_char = match.span()\n                \n                # Check for overlaps with already matched specific KPIs (like ARR/MRR)\n                # This is a simple overlap check; more sophisticated logic might be needed for nested entities.\n                is_sub_match_of_specific_kpi = False\n                if kpi_def[\"type\"] == \"MONEY\": # Only check for sub-match if current is generic MONEY\n                    for ms_start, ms_end in matched_spans:\n                        # If the current MONEY match is completely within or identical to a more specific match\n                        if ms_start <= start_char and end_char <= ms_end:\n                            is_sub_match_of_specific_kpi = True\n                            break\n                if is_sub_match_of_specific_kpi:\n                    continue\n\n                matched_text = match.group(1) # Group 1 usually has the main text we want\n                value_to_parse = matched_text\n                \n                # If a specific regex is provided to extract the value part (e.g., for ARR/MRR full phrase match)\n                if kpi_def.get(\"value_extractor_regex\"):\n                    value_match = re.search(kpi_def[\"value_extractor_regex\"], matched_text)\n                    if value_match:\n                        value_to_parse = value_match.group(0)\n                    else:\n                        # Could not extract specific value part, may use full match or skip\n                        logger.debug(f\"Could not extract value part for {kpi_def['type']} from '{matched_text}'. Skipping value parsing for this instance.\")\n                        value_to_parse = None # Or some default to indicate parsing failed for value part\n                \n                parsed_value = None\n                if value_to_parse and kpi_def['value_parser']:\n                    parsed_value = kpi_def['value_parser'](value_to_parse)\n                \n                # If parsed_value is None after attempting, it means it wasn't a valid numeric KPI form we want\n                # For example, a MONEY regex might match "$test" which `parse_monetary_value` would return None for.\n                # Or a percentage regex matches "100%" but value_parser fails (should not for current % parser)\n                if parsed_value is None and kpi_def['type'] not in ['OTHER_NON_NUMERIC_KPI'] : # Allow KPIs that don't have a numeric value if we define such types\n                    logger.debug(f\"Parsed value is None for matched text '{matched_text}' of type '{kpi_def['type']}'. Skipping this KPI instance.\")\n                    continue\n\n                kpi_entry = {\n                    \"text\": matched_text.strip(),\n                    \"type\": kpi_def['type'],\n                    \"value\": parsed_value,\n                    \"start_char\": start_char,\n                    \"end_char\": end_char,\n                    \"raw_value_parsed\": value_to_parse # Store the string that was sent to the parser\n                }\n                extracted_kpis.append(kpi_entry)\n                \n                # If it's a specific KPI type (not generic MONEY/PERCENTAGE), add its span to prevent generic overlap\n                if kpi_def['type'] not in ['MONEY', 'PERCENTAGE']:\n                    matched_spans.append((start_char, end_char))\n\n        except re.error as e:\n            logger.error(f\"Regex error for KPI type {kpi_def.get('type', 'UNKNOWN')}: {e}\")\n        except Exception as e:\n            logger.error(f\"Unexpected error during KPI extraction for type {kpi_def.get('type', 'UNKNOWN')}: {e}\")\n\n    # Sort by start_char for easier review\n    extracted_kpis.sort(key=lambda x: x['start_char'])\n    logger.info(f\"Extracted {len(extracted_kpis)} KPIs.\")\n    return extracted_kpis\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.DEBUG)\n    sample_text = \"\"\"\n    The company announced $10.5M in ARR and a 25% growth. Our MRR is now $900k.\n    They raised a $5M Series A round. Last year, revenue was 1,200,000 dollars.\n    This cost $50. Their valuation is $100M. We hit 50% profit margin. And a Series B of $20M.\n    Also, plain numbers like 50000 dollars. Or €60K. Or £7.5B.\n    A simple $100. And 15%. MRR of $1.2M. $500K ARR.\n    This is just $5, not $5% or $5M%.\n    Series C funding of $50 million was great.\n    \"\"\"\n    \n    kpis = extract_kpis(sample_text)\n    for kpi in kpis:\n        print(kpi)\n\n    print(\"\\n--- Test monetary parser ---\")\n    test_values = [\"$10.5M\", \"250K\", \"€1,200.50\", \"$1B\", \"100\", \"£5k\", \"¥1000000\", \"text\", None, \"$1.2.3M\"]\n    for tv in test_values:\n        print(f\"\'{tv}\' -> {parse_monetary_value(tv)}\")\n 